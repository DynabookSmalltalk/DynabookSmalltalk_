My instances hold all the dynamic state associated with the execution of either a method activation resulting from a message send or a block activation resulting from a block evaluation.  In addition to their inherited state, this includes the receiver (self), the closure for a BlockClosure activation (which is nil for a method activation), a CompiledMethod, and space in the variable part of the context for arguments, temporary variables, and intermediate results, and the stack pointer to the top of stack in this variable part.

Contexts are created automatically (at least conceptually (*)) whenever a message send activates a method, or a block evaluation activates a block.  The current context can always be accessed via the thisContext pseudo-variable.  For example, explore the following:
	{ thisContext. thisContext copy. thisContext method. thisContext pc. thisContext receiver. thisContext stackPtr. thisContext sender }.

Contexts refer to the context in which they were created via the sender inst var.  An execution stack is made up of of a linked list of contexts, linked through their sender inst var. Returning involves returning back to the sender.  When a context is returned from its sender and pc are nilled, and, if the context is still referred to, the virtual machine guarantees to preserve only the arguments after a return.  A Smalltalk Process is simply a chain of contexts specific to that process.  The debugger is essentially a Process inspector.  Stepping in the debugger is done by sending messages to contexts to get them to execute their bytecodes.  See methods in the instruction decoding protocol.

Contexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.

Contexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a Context except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.

(*) efficient virtual machines create contexts lazily on demand, avoiding the overhead of creating them on every message send and of copying receiver and arguments from sender context to caller context.  This optimization is invisible to the Smalltalk system.