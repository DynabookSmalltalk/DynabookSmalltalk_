I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. I can emit for value in the usual way, in which case I create a BlockClosure to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in certain optimized control structures (see MessageNode class>>initialize MacroSelectors).

Instance Variables
    actualScopeIfOptimized:    <nil | BlockNode>
    arguments:                    <SequencableCollection of: TempVariableNode>
    blockExtent:                <nil | Interval>
    closureCreationNode:        <LeafNode>
    copiedValues:                <nil | (SequencableCollection of: TempVariableNode)>
    nArgsNode:                    <nil | Integer>
    optimized:                    <Boolean>
    optimizedMessageNode:    <nil | MessageNode>
    remoteTempNode:            <nil | RemoteTempVectorNode>
    returns:                    <Boolean>
    size:                        <nil | Integer>
    startOfLastStatement:        <nil | Integer>
    statements:                <SequencableCollection of: ParseNode>
    temporaries:                <SequencableCollection of: TempVariableNode>
    tempsMark:                    <nil | Integer>

actualScopeIfOptimized
    - if the receiver has been inlined this is the non-optimized BlockNode the receiver is inlined into.

arguments
    - the sequence of arguments to the block (or method if a top-level block)

blockExtent
    - the interval defining the range of block scopes the receiver comprises, which is itself and any blocks it may contain.  See #analyseArguments:temporaries:rootNode:

closureCreationNode
    - a place-holder representing the body of the block.

copiedValues
    - blocks do not reference the temporary variables of their outer context they close over directly; instead, temporary variables which won't change value are collected and copied into the block, and temporary variables that are modified either within the block or after it has closed over the variables are allocated in a remote temp vector that again becomes one of the block's copied values.  In this way, a block refers to the outer temporaries it closes over only through copiedValues.  copiedValues is the sequence of these TempVariableNodes.

nArgsNode
    - a place holder for the encoder to allow it to number block temporaries

optimized
    - true if the receiver is inlined, false if a true block

optimizedMessageNode
    - the MessageNode in which the receiver is optimized, if it is optimized.

remoteTempNode
    - if any of the blocks nested into the receiver either modify a temp or access a temp that is modified after the block is created, then this temp is allocated remotely in a remote temp vector that allows the temp's location to be shared between blocks.  This is the node that creates the remote temp vector.

returns
    - true if the receiver contains a method return.

size
    - the size of the block's bytecodes if it is generated by embedding its bytecodes within an enclosing CompiledMethod.

startOfLastStatement
    - the index in the source of the start of the last statement in the block.

statements
    - the sequence of statements comprising the receiver

temporaries
    - the sequence of temporaries (including the remoteTempNode if any) of block-local temporaries

tempsMark
    - the index in the source of the last block-local temporary, used to auto-insert temps declared during compilation