instruction decoding
send: selector super: superFlag numArgs: numArgs

	| args rcvr selNode msgNode messages |
	args := Array new: numArgs.
	(numArgs to: 1 by: -1) do:
		[:i | args at: i put: stack removeLast].
	rcvr := stack removeLast.
	superFlag ifTrue: [rcvr := constructor codeSuper].
	selNode := constructor codeAnySelector: selector.
	rcvr == CascadeFlag
		ifTrue:
			["May actually be a cascade or an ifNil: for value."
			self willJumpIfFalse
				ifTrue: "= generated by a case macro"
					[selector == #= ifTrue:
						[" = signals a case statement..."
						statements addLast: args first.
						stack addLast: rcvr. "restore CascadeFlag"
						^ self].
					selector == #== ifTrue:
						[" == signals an ifNil: for value..."
						stack removeLast; removeLast.
						rcvr := stack removeLast.
						stack addLast: IfNilFlag;
							addLast: (constructor
								codeMessage: rcvr
								selector: selNode
								arguments: args).
						^ self]]
				ifFalse:
					[(self willJumpIfTrue and: [selector == #==]) ifTrue:
						[" == signals an ifNotNil: for value..."
						stack removeLast; removeLast.
						rcvr := stack removeLast.
						stack addLast: IfNilFlag;
							addLast: (constructor
								codeMessage: rcvr
								selector: selNode
								arguments: args).
						^ self]].
			msgNode := constructor
							codeCascadedMessage: selNode
							arguments: args.
			stack last == CascadeFlag ifFalse:
				["Last message of a cascade"
				statements addLast: msgNode.
				messages := self popTo: stack removeLast.  "Depth saved by first dup"
				msgNode := constructor
								codeCascade: stack removeLast
								messages: messages]]
		ifFalse:
			[msgNode := constructor
						codeMessage: rcvr
						selector: selNode
						arguments: args].
	stack addLast: msgNode